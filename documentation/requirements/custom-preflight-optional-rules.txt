Request:
--------
I would like to create a new class of preflight rule: optional rules

These will be custom rules but they will be ... optional.
Two possible approaches:
1 - runtime (with a releaserun)
2 - a project level setting

I am leaning to 2 as some may not agree with all usecases. For example: "open external links in new window" or "flag inline css" (sometimes it can be OK)

No coding, no changes. Review the idea and ask questions.

Questions:
----------
1. Default state: Should optional rules be OFF by default (opt-in) or ON by default (opt-out)?
2. Scope of "optional":
- Are these entirely new rules that don't exist today?
- Or would some existing rules become "optional" (e.g., demote current rules)?
3. Scoring impact: When an optional rule is enabled and fails, should it:
- Contribute to score like normal rules (with its severity)?
- Have a fixed lower severity (e.g., always LOW)?
- Be informational only (no score impact, just flagged)?
4. UI location: Where would you configure this?
- Project Settings page (alongside name, siteUrl, sitemapUrl)?
- A dedicated "Rules Configuration" section?
5. Granularity: One toggle per optional rule, or grouped toggles (e.g., "Enable all accessibility optional rules")?
6. Inheritance/defaults: Should there be a global default that projects inherit, or purely per-project?

Answers:
-------
1 - Project level, on by default, but can be changed at anytime
2 - New rules
3 - Contribute to score like normal rules
4 - Project Settings page
5 - One toggle per (checkboxes)
6 - All optional rules will be available on all projects

Questions:
---------

Data model:
7. Storage: Where should the project's optional rule settings be stored?
- New JSON column on Project table (e.g., optionalRulesConfig: Json)?
- New junction table (e.g., ProjectOptionalRules with projectId, ruleCode, enabled)?
8. Rule definition: How should optional rules be identified in the ReleaseRule table?
- New boolean column isOptional on ReleaseRule?
- New category/classification field?

Behavior:
9. Existing projects: When you add a new optional rule, should it automatically be ON for all existing projects (matching "on by default"), or only for newly created
projects?
10. Rule changes: If an optional rule is later changed to non-optional (or vice versa), how should existing project settings behave?

Worker:
11. When to check settings: Should the worker fetch project settings once at the start of a test run, or should this be baked into the ReleaseRun snapshot (like URLs are)?

Answers:
-------
7 - Make a recommendation
8 - boolean. This option should be available in the preflight rules screen
9 - great question. let's actually make all optional rules OFF by default
10 - should be removed from the project settings page
11 - sounds like "baked into the ReleaseRun snapshot" is the easy/best option. review and recommend

----

Questions:
7. Storage: Where should the project's optional rule settings be stored?
- New JSON column on Project table (e.g., optionalRulesConfig: Json)?
- New junction table (e.g., ProjectOptionalRules with projectId, ruleCode, enabled)?
8. Rule definition: How should optional rules be identified in the ReleaseRule table?
- New boolean column isOptional on ReleaseRule?
- New category/classification field?

Response/Plan v1:
----------------
● Recommendations:

7. Storage
Recommend: JSON column on Project table

model Project {
// ... existing fields
disabledOptionalRules  Json?  // Array of rule codes: ["EXTERNAL_LINK_TARGET", "INLINE_CSS"]
}

Rationale:
- Simple schema, minimal migration
- Matches existing patterns (urls, selectedTests on ReleaseRun are JSON)
- Store as array of disabled codes (since default is OFF, storing disabled list is more efficient when most are disabled)
- Easy to check: if (!disabledOptionalRules.includes(ruleCode))

Wait - you said OFF by default now. So we should store enabled codes instead:

enabledOptionalRules  Json?  // Array of enabled rule codes: ["EXTERNAL_LINK_TARGET"]

11. Snapshot in ReleaseRun

Recommend: Yes, snapshot

Add to ReleaseRun:
model ReleaseRun {
// ... existing fields
enabledOptionalRules  Json?  // Snapshot of enabled optional rules at run creation
}

Rationale:
- Matches existing immutability pattern (URLs are frozen at run creation)
- Audit trail: know exactly which rules were active for that run
- No mid-test race conditions
- Worker reads from ReleaseRun, no extra Project fetch needed

Flow:
1. User creates ReleaseRun → API reads project.enabledOptionalRules → copies to releaseRun.enabledOptionalRules
2. Worker processes run → checks releaseRun.enabledOptionalRules to decide which optional rules to execute

Does this align with your thinking?

--

Answers/Response:
----------------
7 - what happens if an enabled optional rule becomes a non-optional rule? would a table be a better solution (would be filtered out automatically)


--

Response/Plan v1.1:
----------------

Optional Rules - Final Design
Schema changes:i

1. ReleaseRule - Add isOptional Boolean @default(false)
2. ProjectOptionalRule (new junction table)
- projectId, ruleCode, enabled
- Records cleaned up when rule becomes non-optional
3. ReleaseRun - Add enabledOptionalRules Json? (snapshot at creation)

Behavior:
- Optional rules are OFF by default for all projects
- Project Settings page shows checkboxes for each optional rule
- When ReleaseRun is created, enabled optional rules are snapshotted
- Worker checks snapshot to decide which optional rules to run
- When isOptional flips to false, delete related ProjectOptionalRule records

UI touchpoints:
- Project Settings: checkboxes to enable/disable optional rules
- Preflight Rules admin screen: toggle to mark rule as optional


Detailed Implementation Plan: Optional Preflight Rules
------------------------------------------------------

Phase 1: Schema Changes

1.1 Update Prisma schema

// Add to ReleaseRule model
model ReleaseRule {
// ... existing fields
isOptional  Boolean  @default(false)
}

// New junction table
model ProjectOptionalRule {
id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
projectId String   @db.Uuid
ruleCode  String
enabled   Boolean  @default(true)

project   Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)

createdAt DateTime @default(now())
updatedAt DateTime @updatedAt

@@unique([projectId, ruleCode])
@@index([projectId])
}

// Add relation to Project
model Project {
// ... existing fields
optionalRules  ProjectOptionalRule[]
}

// Add snapshot to ReleaseRun
model ReleaseRun {
// ... existing fields
enabledOptionalRules  Json?  // string[] of rule codes
}

1.2 Create migration
npx prisma migrate dev --name add_optional_rules

---
Phase 2: API Endpoints

2.1 Update ReleaseRule API (app/api/settings/preflight-rules/[id]/route.ts)

- PATCH: Allow updating isOptional field
- When isOptional changes to false: Delete related ProjectOptionalRule records

2.2 New Project Optional Rules API (app/api/projects/[id]/optional-rules/route.ts)

- GET: Return list of optional rules with enabled status for project
[
{ "code": "EXTERNAL_LINK_TARGET", "name": "External links open in new window", "enabled": false },
{ "code": "INLINE_CSS_FLAG", "name": "Flag inline CSS", "enabled": true }
]
- PATCH: Update enabled status for a rule
{ "ruleCode": "EXTERNAL_LINK_TARGET", "enabled": true }

2.3 Update ReleaseRun creation (app/api/release-runs/route.ts)

- On POST, query enabled optional rules for project
- Snapshot into enabledOptionalRules JSON field

---
Phase 3: Worker Changes

3.1 Update custom rules processor (worker/providers/preflight/custom-rules.ts)

- Receive enabledOptionalRules from ReleaseRun
- Load all rules from DB, filter:
- Non-optional rules: always run
- Optional rules: only run if code is in enabledOptionalRules

3.2 Update worker job handler

- Pass releaseRun.enabledOptionalRules to preflight processor

---
Phase 4: Admin UI - Preflight Rules

Location: app/(dashboard)/settings/preflight-rules

4.1 Add "Optional" column to rules table
- Checkbox or toggle per rule
- On change, PATCH to API

4.2 Visual indicator
- Badge or icon showing rule is optional

---
Phase 5: Project Settings UI

Location: app/(dashboard)/projects/[id] or similar

5.1 New section: "Optional Preflight Rules"
- List all optional rules (from ReleaseRule where isOptional=true)
- Checkbox per rule showing enabled/disabled
- On change, PATCH to project optional rules API

5.2 Empty state
- "No optional rules configured" if none exist

---
Phase 6: Seed Script Updates

6.1 Update prisma/seed-release-rules.ts
- Add isOptional: true to any initial optional rules
- Or leave empty if optional rules will be added later via admin UI

---
File Summary
┌───────────────────────────────────────────────────┬───────────────────────────────────────────────────────────┐
│                       File                        │                          Action                           │
├───────────────────────────────────────────────────┼───────────────────────────────────────────────────────────┤
│ prisma/schema.prisma                              │ Add isOptional, ProjectOptionalRule, enabledOptionalRules │
├───────────────────────────────────────────────────┼───────────────────────────────────────────────────────────┤
│ app/api/settings/preflight-rules/[id]/route.ts    │ Update PATCH for isOptional, cleanup on change            │
├───────────────────────────────────────────────────┼───────────────────────────────────────────────────────────┤
│ app/api/projects/[id]/optional-rules/route.ts     │ New: GET, PATCH                                           │
├───────────────────────────────────────────────────┼───────────────────────────────────────────────────────────┤
│ app/api/release-runs/route.ts                     │ Snapshot enabledOptionalRules on creation                 │
├───────────────────────────────────────────────────┼───────────────────────────────────────────────────────────┤
│ worker/providers/preflight/custom-rules.ts        │ Filter rules based on snapshot                            │
├───────────────────────────────────────────────────┼───────────────────────────────────────────────────────────┤
│ app/(dashboard)/settings/preflight-rules/page.tsx │ Add Optional column/toggle                                │
├───────────────────────────────────────────────────┼───────────────────────────────────────────────────────────┤
│ app/(dashboard)/projects/[id]/page.tsx            │ Add Optional Rules section                                │
├───────────────────────────────────────────────────┼───────────────────────────────────────────────────────────┤
│ prisma/seed-release-rules.ts                      │ Add isOptional field to rule definitions                  │
└───────────────────────────────────────────────────┴───────────────────────────────────────────────────────────┘
---
Execution Order

1. Phase 1 (Schema) - foundation
2. Phase 2.1-2.2 (APIs) - backend support
3. Phase 4 (Admin UI) - ability to mark rules optional
4. Phase 5 (Project UI) - ability to enable/disable per project
5. Phase 2.3 + Phase 3 (ReleaseRun snapshot + Worker) - execution support
6. Phase 6 (Seed) - optional, if adding default optional rules


--

Updates:
- Add optional rules lookup to new project page
- Put lookup code into a shared component

Questions:
1. Save behavior: Currently edit page saves immediately on toggle (PATCH per change). New page collects selections and sends on form submit.
Should we:
- Keep this difference (immediate save on edit, batch on new)?
- Or unify to one pattern?
2. Component scope: Should the shared component be:
- Just the UI (list of checkboxes with severity badges)?
- Or include the fetch logic too (with a prop to determine which endpoint)?
3. Location: You mentioned /components/projects - should this be:
- components/projects/OptionalRulesSection.tsx?
- Or a different name/structure?
4. Props pattern: I'm thinking:
<OptionalRulesSection
projectId={id}           // undefined for new, string for edit
enabledRules={set}       // local state for new
onToggle={fn}            // handler for both
/>
4. The component would fetch rules internally, but behavior differs based on whether projectId exists. Does this align with your thinking?

1 - yes, let's unify to use "save" (batch)
2 - UI and fetch - but make a recommendation
3 - yes components/projects/OptionalRulesSection.tsx
4 - explain question

---

Recommendation for #2:

I'd recommend pure UI component with parent handling fetch. Here's why:
Option A: Component fetches internally
<OptionalRulesSection
projectId={id}  // if exists, fetches /api/projects/[id]/optional-rules
                // if undefined, fetches /api/release-rules/optional
enabledRules={set}
onToggle={fn}
/>
- Simpler parent code
- But: component has side effects, harder to test, mixed concerns

Option B: Pure UI component (recommended)
<OptionalRulesSection
rules={optionalRules}        // parent fetches, passes data
enabledRules={enabledRules}  // Set<string> of enabled codes
onToggle={handleToggle}      // (code, enabled) => void
loading={loading}
/>
- Parent handles fetching (each page knows its endpoint)
- Component is pure render - just displays rules with checkboxes
- Easier to test, clearer separation, more reusable

For #4 explanation:

I was asking about the props interface - what data the component receives and how it communicates back. With Option B above:
- rules = the list of optional rules to display
- enabledRules = which are currently checked
- onToggle = callback when user clicks a checkbox
- loading = show loading state

---

Answers:
-------
I'm on fence on #2. I would prefer not to have redundant fetch code (if that is the recommendation)
#4 - make a recommendation

Option C: Self-contained component with state callback
<OptionalRulesSection
projectId={projectId}  // undefined for new, string for edit
onEnabledRulesChange={(enabledCodes) => setEnabledRules(enabledCodes)}
/>

The component:
1. Fetches rules internally (uses /api/release-rules/optional for new, /api/projects/[id]/optional-rules for edit)
2. Manages its own checkbox state internally
3. Calls onEnabledRulesChange whenever user toggles, so parent always has current state for save
4. For edit: initializes checkboxes from API response
5. For new: all unchecked initially

Parent pages become simple:
// New page
const [enabledRules, setEnabledRules] = useState<string[]>([])

<OptionalRulesSection onEnabledRulesChange={setEnabledRules} />

// On submit: include enabledRules in POST

// Edit page
const [enabledRules, setEnabledRules] = useState<string[]>([])

<OptionalRulesSection
projectId={projectId}
onEnabledRulesChange={setEnabledRules}
/>

// On submit: include enabledRules in PATCH

Benefits:
- No duplicate fetch code
- Component is self-contained
- Parent just receives the current state for saving
- Clean separation

----
